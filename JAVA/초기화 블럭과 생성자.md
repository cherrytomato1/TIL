# 초기화 블럭과 생성자

## 초기화 블럭

- 초기화 블럭은 스태틱 초기화 블럭과 인스턴스 초기화 블럭이 있다. 이들은 클래스 내에 선언되며 각각 static {}, {} 로 작성한다

### static block

- 스태틱 초기화 블럭은 클래스가 로딩될 때 호출되며 따라서 각 클래스당 최초 1회만 실행된다.
- 스태틱 블럭은 객체가 생성되기 이전에 수행되므로 인스턴스 멤버에 접근할 수 없다.

그렇다면 스태틱 메서드를 스태틱 초기화 블럭에서 호출할 수 있을까?

```java
class SBTest{
    static int A;
    static {
        test();
        A++;
        System.out.println("static block  : " + A);		
    }

    static void test() {
        A++;
        System.out.println("static method  : " + A);
    }
}

/** 
	 * 출력은 다음과 같다
	 * static method : 1
	 * static block : 2
 */
```

- 스태틱 블록에서도 스태틱 메소드를 호출할 수 있다.
- 클래스 로딩시 멤버를 먼저 힙에 올린 후 초기화 블럭이 수행된다.
- 이 때 클래스가 로딩되는 시점은 레퍼런스 변수를 만드는 것을 제외한 클래스가 최초로 호출될 때이다.

```java
public class StaticBlockTest {
    public static void main(String[] args) {
        SBTest.test();
    }
}
/** 
	 * 출력은 다음과 같다
	 * static method : 1
	 * static block : 2
	 * static method : 3
 */
```

- 위와같이 스태틱 메서드를 호출했을 때 다음과 같은 순서로 수행된다
    1. 클래스 로딩
        1. 멤버 초기화
        2. 스태틱 블록 호출
            1. 스태틱 메서드 호출
    2. 스태틱 메서드 호출
- 따라서 첫번째 static method 출력은 스태틱 블록이 호출한 메서드, 이후 세 번째 스태틱 메서드 호출이 메인 메서드에서 호출한 것이다.

### instance block

- 인스턴스 초기화 블럭은 인스턴스가 생성될 때마다 수행된다.
- 인스턴스를 new 키워드를 통해 생성했을때 수행 순서는 다음과 같다.
    1. 인스턴스 멤버 초기화
    2. 인스턴스 초기화 블럭 수행
    3. 생성자 수행
- 따라서 인스턴스 메서드를 초기화 블럭 및 생성자에서 호출할 수 있다.

```java
class SBTest{
    static int A ;
    static {
        test();
        A++;
        System.out.println("static block  : " + A);
    }

    {
        instanceMethod();
        A++;
        System.out.println("instance block  : " + A);
    }

    static void test() {
        A++;
        System.out.println("static method  : " + A);
    }

    public SBTest() {
        instanceMethod();
        A++;
        System.out.println("contsructor  : " + A);
    }

    private void instanceMethod() {
        A++;
        System.out.println("instance method : " + A);
    }
}

public class StaticBlockTest {
    public static void main(String[] args) {

        SBTest.test();
        SBTest a = new SBTest();		
        SBTest b = new SBTest();
        /** 
         * 출력은 다음과 같다
         * static method  : 1
         * static block  : 2
         * static method  : 3
         * instance method : 4
         * instance block  : 5
         * instance method : 6
         * contsructor  : 7
         * instance method : 8
         * instance block  : 9
         * instance method : 10
         * contsructor  : 11
        */
    }
}
```

- 위와 같이 인스턴스 블럭은 인스턴스가 생성될 때마다 수행되며 멤버의 초기화 이후, 생성자 호출 이전에 수행됨.

## 생성자

- 생성자는 new 키워드를 통해 인스턴스를 생성할 때 인스턴스 블록 이후 수행한다.
- 모든 생성자는 생성자의 가장 첫줄에 단 한번 다른 생성자를 호출해야한다. 첫 줄이 아니거나, 여러번 생성자를 호출 할 수 없다

```java
class SuperClass{
    int A;
    public SuperClass() {
        //super() 가 생략됨
        A++;
    }
}

class SubClass extends SuperClass{

    public SubClass(){
        //super() 가 생략됨
        A--;
    }

    public SubClass(int num) {
        //super() 가 생략됨
        A += num;
    }

    public SubClass(int num, int num2) {
        this(num);
        A -= num2;
    }
}

public class ConstructorTest {
    public static void main(String[] args) {
        SuperClass s = new SubClass(10);
        System.out.println(s.A);

        SuperClass s2 = new SubClass(10, 5);
        System.out.println(s2.A);
        /**
         * 출력되는 값
         * 11
         * 6
         */
    }
}
```

- 모든 생성자는 this()나 super()로 다른 생성자를 호출해야한다. 이 때 명시적으로 작성하지 않는다면 컴파일러가 자동으로 super()를 호출한다.
- 모든 클래스는 Object 클래스를 상속받기 때문에 클래스 내의 최소 1개의 생성자는 Object의 기본 생성자를 호출한다.
- 클래스 내에 아무런 생성자도 작성하지 않았다면 컴파일러가 기본 생성자를 추가한다.
- 명시적으로 생성자를 작성했다면 기본생성자를 생성하지 않는다.

```java

class SuperClass{
    int A;
    public SuperClass(int num) {
        //super() 가 생략됨
        A =+ num;
    }
}

class SubClass extends SuperClass{
	
    public SubClass(){
        //super() 가 생략됨
        //super() 가 존재하지 않으므로 컴파일 에러
        A--;
    }

    public SubClass(int num, int num2) {
        super(num);
        A -= num2;
    }
}

```

- 위의 코드는 슈퍼클래스의 생성자를 작성했기 때문에 컴파일러가 기본생성자를 만들지 않는다.
- 서브클래스의 기본생성자에서 명시적 생성자 호출을 하지 않았기 때문에 super()를 호출하게 되는데, super()가 존재하지 않으므로 컴파일 에러.
- 서브클래스의 두번째 생성자에서는 슈퍼클래스의 생성자를 명시적으로 호출했기 때문에 super()를 호출하지 않으므로 정상적으로 동작한다.
